## 테스트 더블과 모의객체

- 어떤 클래스는 수행할 떄 다른 클래스에 의존
- 종속성에 의존하지 말고 격리된 방식으로 테스트하는데 초점을 맞춤
- 테스트 대상 클래스를 구체적인 의존성과 함꼐 수행하는 일은 너무 느림
- 테스트 더블
  - 모의 객체 생성
  - 테스트 내에서 가짜 구성요소 B를 완전히 제어 가능
  - 테스트 맥락에 따라 B처럼 행동하도록 할 수 있음
  - 실제 객체에 대한 의존성을 줄임
- 다른 객체 시뮬레이션
  - 더 큰 제어권을 가짐
  - 시뮬레이션은 빠름
  - 개발자는 모의 객체를 설꼐 기법으로 사용하여 클래스 간의 상호작용을 반영할 수 있음

- 더미, 페이크, 스텁, 모의 객체, 스파이
  - 더미 객체
    - 더미는 테스트 대상 클래스에 전달되지만 절대 사용되지 않는 객체
    - 비즈니스 애플리케이션에 전달해야 할 인수가 여러 개 있지만 테스트는 이들 중 몇 개만 수행할 때 흔히 볼 수 있음
      - 더미 Address 객체를 테스트해야할 떄, Address 등이 필요할 수 있음
        - 어떤 Address를 가지든 상관 없을 때 더미 객체 활용 가능
  - 페이크 객체
    - 페이크 객체는 시뮬레이션 하려는 클래스같이 실제로 동작하는 구현체
    - 이 페이크 객체는 실제 데이터베이스보다 더 다루기 쉬움
    - 인메모리 데이터베이스 등
  - 스텁
    - 테스트 과정에서 수행된 호출에 대해 하드 코딩된 응답을 제공
    - 페이크 객체와는 달리 실제로 동작하는 구현체가 없음
    - 스텁은 가장 인기 있는 시뮬레이션 유형
    - 대부분의 경우 테스트 대상 메서드가 실행을 계속할 수 있도록 종속성 클래스는 어떤 값을 반환해야 함
  - 모의 객체
    - 모의 객체는 메서드의 응답을 설정할 수 있다는 점에서 스텁과 같은 역할
    - 모든 객체의 상호작용을 저장하여 단언문에 활용할 수 있도록 함
    - getAllInvoices 메서드가 한 번만 호출되기 바랄 수 있음
      - 두 번 호출된다면 이는 버그 발생 -> 단언문으로 체크 가능
    - 모킹 프레임워크
      - 메서드는 어떤 특정 매개변수로 호출되지 않는다
      - 메서드는 매개변수 A로 두 번 호출되고 매개변수 B로 한 번 호출된다 등의 상호작용 단언 가능
  - 스파이
    - 의존성을 감시 함
    - 실제 객체를 감싸서 그 행동을 관찰
    - 우리는 객체를 시뮬레이션하는 게 아니라 감시하고 있는 근본 객체와의 모든 상호작용을 기록
    - 모의 객체를 사용하는 것보다 실제로 구현하는 게 훨씬 쉽고 테스트 대상 메서드가 의존 대상과 어떻게 상호작용하는지 단언하고자 하는 경우 사용
    - 현업에서 보기 힘듬

# 현업에서의 모의 객체
- 모의 객체의 단점
  - 테스트를 덜 현실적으로 만듬
  - 모의 객체가 대규모로 잘 동작하도록 하려면 계약을 신경 써서 설계해야 함
  - 계약이 잘 설계되고 안정적이라면 모의 객체 사용을 두려워할 필요가 없음
  - 모의 객체를 사용한 테스트는 자연스럽게 모의 객체를 사용하지 않는 테스트와 결합
    - 테스트가 여러가지 정보를 많이 알고있어야 하므로 테스트 변경이 어려움

### 모의 객체 사용 대상
- 의존성이 너무 느린 경우
  - 의존성이 외부 인프라와 통신
  - 시뮬레이션하기 어려운 경우

### 모의 객체 비추천 대상
- 엔티티
  - 엔티티는 비즈니스 개념을 표현하는 클래스
  - 엔티티를 모의하는데 공수가 더 많이 듬
  - 그냥 생성하는 것을 추천
- 네이티브 라이브러리와 유틸리티 메서드
- 충분히 단순한 의존성

## 날짜 및 시간 래퍼
- 소프트웨어 시스템은 날짜와 시간 정보를 자주 다룸
- 날짜 및 시간 연산은 흔하게 일어나므로 전용 클래스로 감싸는 것이 좋음

## 소유하지 않은 대상은 추상화할 것
- 외부 라이브러리를 직접적으로 노출하기보다 캡슐화하는 추상화 객체 사용
  - Clock 싱글턴 객체가 실제 라이브러리를 호출하여 제공하지만, 사용하는 대상은 Clock의 내부 구현을 모름

## kotest
- 코테스트를 사용할 떄, 싱글턴의 경우 mockkObject()를 사용해야함
```
io.mockk.MockKException: Missing mocked calls inside every { ... } block: make sure the object inside the block is a mock
```
- every {} 구분을 사용하려면 내부에 사용하고자 하는 것은 반드시 mockk()으로 선언되어야 함